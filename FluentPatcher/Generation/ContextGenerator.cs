using FluentPatcher.Generator.Models;
using System.Text;

namespace FluentPatcher.Generator;

/// <summary>
/// Generates the PatchContext class that tracks all changes during patching.
/// </summary>
internal static class ContextGenerator
{
    public static string Generate(PatcherModel model)
    {
        var sb = new StringBuilder();
            
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using FluentPatcher.Context;");
        sb.AppendLine();
        sb.AppendLine($"namespace {model.Namespace}");
        sb.AppendLine("{");
            
        // Generate the PatchContext class
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Tracks changes made during patching of {model.ClassName}.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public sealed class {model.ContextClassName} : PatchContextBase");
        sb.AppendLine("    {");
            
        // Generate properties for each field
        foreach (var prop in model.Properties)
        {
            // For Patchable<T>, use the inner type for Old/New values
            var valueTypeName = prop.IsPatchable ? prop.PatchableInnerType ?? "object" : prop.TypeName;
            
            sb.AppendLine($"        #region {prop.Name}");
            sb.AppendLine();
                
            // Changed flag
            sb.AppendLine($"        /// <summary>Indicates whether {prop.Name} was changed.</summary>");
            sb.AppendLine($"        public bool {prop.Name}Changed {{ get; internal set; }}");
            sb.AppendLine();
                
            // Old value
            sb.AppendLine($"        /// <summary>The original value of {prop.Name} before patching.</summary>");
            sb.AppendLine($"        public {valueTypeName} Old{prop.Name} {{ get; internal set; }}");
            sb.AppendLine();
                
            // New value
            sb.AppendLine($"        /// <summary>The new value of {prop.Name} after patching.</summary>");
            sb.AppendLine($"        public {valueTypeName} New{prop.Name} {{ get; internal set; }}");
            sb.AppendLine();
                
            sb.AppendLine($"        #endregion");
            sb.AppendLine();
        }
            
        // Generate HasChanges method
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Returns true if any property was changed during patching.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public override bool HasChanges()");
        sb.AppendLine("        {");
            
        var changedProps = model.Properties;
        if (changedProps.Count == 0)
        {
            sb.AppendLine("            return false;");
        }
        else
        {
            sb.Append("            return ");
            sb.AppendLine(string.Join(" ||\n                   ", changedProps.Select(p => $"{p.Name}Changed")));
            sb.AppendLine("                   ;");
        }
            
        sb.AppendLine("        }");
        sb.AppendLine();
            
        // Generate GetChangedValues method for easy access
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Gets a dictionary of all changed property names and their new values.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public Dictionary<string, object?> GetChangedValues()");
        sb.AppendLine("        {");
        sb.AppendLine("            var result = new Dictionary<string, object?>();");
            
        foreach (var prop in changedProps)
        {
            sb.AppendLine($"            if ({prop.Name}Changed) result[\"{prop.Name}\"] = New{prop.Name};");
        }
            
        sb.AppendLine("            return result;");
        sb.AppendLine("        }");
        sb.AppendLine();
            
        // Generate summary method
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Gets a human-readable summary of all changes.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public string GetChangesSummary()");
        sb.AppendLine("        {");
        sb.AppendLine("            var changes = new List<string>();");
            
        foreach (var prop in changedProps)
        {
            sb.AppendLine($"            if ({prop.Name}Changed) changes.Add($\"{prop.Name}: '{{Old{prop.Name}}}' -> '{{New{prop.Name}}}'\");");
        }
            
        sb.AppendLine("            return string.Join(\"\\n\", changes);");
        sb.AppendLine("        }");
            
        sb.AppendLine("    }");
        sb.AppendLine("}");
            
        return sb.ToString();
    }
}