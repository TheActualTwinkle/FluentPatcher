using FluentPatcher.Generator.Models;
using System.Text;

namespace FluentPatcher.Generator;

/// <summary>
/// Generates extension methods to apply DTO patches to entities.
/// </summary>
internal static class PatcherClassGenerator
{
    public static string Generate(PatcherModel model)
    {
        var sb = new StringBuilder();
            
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using FluentPatcher.Context;");
        sb.AppendLine();
        sb.AppendLine($"namespace {model.Namespace}");
        sb.AppendLine("{");
            
        // Generate static extensions class
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Extension methods for applying {model.ClassName} patches to entities.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static class {model.ExtensionClassName}");
        sb.AppendLine("    {");
            
        // Main extension: generic ApplyTo with PatchResult
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Applies this {model.ClassName} patch to the target entity and returns the result with change context.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <typeparam name=\"TEntity\">The type of entity to patch.</typeparam>");
        sb.AppendLine("        /// <param name=\"patch\">The patch DTO.</param>");
        sb.AppendLine("        /// <param name=\"existing\">The existing entity to patch.</param>");
        sb.AppendLine("        /// <param name=\"cloneEntity\">Optional function to clone the entity. If null, modifies in place.</param>");
        sb.AppendLine($"        /// <returns>A PatchResult containing the updated entity and {model.ContextClassName}.</returns>");
        sb.AppendLine($"        public static PatchResult<TEntity, {model.ContextClassName}> ApplyTo<TEntity>(");
        sb.AppendLine($"            this {model.ClassName} patch,");
        sb.AppendLine($"            TEntity existing,");
        sb.AppendLine($"            Func<TEntity, TEntity>? cloneEntity = null) where TEntity : class");
        sb.AppendLine("        {");
        sb.AppendLine("            var entity = ApplyPatchInternal(existing, patch, out var context, cloneEntity);");
        sb.AppendLine($"            return new PatchResult<TEntity, {model.ContextClassName}>(entity, context);");
        sb.AppendLine("        }");
        sb.AppendLine();
            
        // Internal core logic reused by all entry points
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Core implementation that applies the patch and outputs context.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        private static TEntity ApplyPatchInternal<TEntity>(");
        sb.AppendLine($"            TEntity existing,");
        sb.AppendLine($"            {model.ClassName} patch,");
        sb.AppendLine($"            out {model.ContextClassName} context,");
        sb.AppendLine($"            Func<TEntity, TEntity>? cloneEntity = null) where TEntity : class");
        sb.AppendLine("        {");
        sb.AppendLine("            if (existing == null) throw new ArgumentNullException(nameof(existing));");
        sb.AppendLine("            if (patch == null) throw new ArgumentNullException(nameof(patch));");
        sb.AppendLine();
        sb.AppendLine("            // Always work on a cloned instance so the original is not mutated.");
        sb.AppendLine("            var updated = cloneEntity != null ? cloneEntity(existing) : ShallowClone(existing);");
        sb.AppendLine($"            context = new {model.ContextClassName}();");
        sb.AppendLine("            var entityType = typeof(TEntity);");
        sb.AppendLine();
            
        // Generate patch logic for each property
        foreach (var prop in model.Properties)
        {
            GeneratePropertyPatchCode(sb, prop);
        }
            
        sb.AppendLine("            return updated;");
        sb.AppendLine("        }");
        sb.AppendLine();
            
        // Helper: shallow clone using reflection
        sb.AppendLine("        private static TEntity ShallowClone<TEntity>(TEntity source) where TEntity : class");
        sb.AppendLine("        {");
        sb.AppendLine("            var type = typeof(TEntity);");
        sb.AppendLine("            var clone = (TEntity)Activator.CreateInstance(type)!;");
        sb.AppendLine("            foreach (var prop in type.GetProperties(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public))");
        sb.AppendLine("            {");
        sb.AppendLine("                if (!prop.CanRead || !prop.CanWrite) continue;");
        sb.AppendLine("                var value = prop.GetValue(source);");
        sb.AppendLine("                prop.SetValue(clone, value);");
        sb.AppendLine("            }");
        sb.AppendLine("            return clone;");
        sb.AppendLine("        }");
        sb.AppendLine();
            
        // Convenience extension that ignores context and returns only entity
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Applies the patch and returns only the updated entity.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static TEntity ApplyToEntity<TEntity>(");
        sb.AppendLine($"            this {model.ClassName} patch,");
        sb.AppendLine($"            TEntity existing,");
        sb.AppendLine($"            Func<TEntity, TEntity>? cloneEntity = null) where TEntity : class");
        sb.AppendLine("        {");
        sb.AppendLine("            return ApplyTo(patch, existing, cloneEntity).Entity;");
        sb.AppendLine("        }");
        sb.AppendLine();
            
        // Convenience extension that returns only context
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Applies the patch and returns only the change context.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static {model.ContextClassName} ApplyToContext<TEntity>(");
        sb.AppendLine($"            this {model.ClassName} patch,");
        sb.AppendLine($"            TEntity existing,");
        sb.AppendLine($"            Func<TEntity, TEntity>? cloneEntity = null) where TEntity : class");
        sb.AppendLine("        {");
        sb.AppendLine("            return ApplyTo(patch, existing, cloneEntity).Context;");
        sb.AppendLine("        }");
        sb.AppendLine();
            
        sb.AppendLine("    }");
        sb.AppendLine("}");
            
        return sb.ToString();
    }

    private static void GeneratePropertyPatchCode(StringBuilder sb, PropertyModel prop)
    {
        var targetProp = prop.EffectiveTargetName;
            
        sb.AppendLine($"            // Patch {prop.Name}");
        sb.AppendLine($"            var prop{prop.Name} = entityType.GetProperty(\"{targetProp}\");");
        sb.AppendLine($"            if (prop{prop.Name} != null && prop{prop.Name}.CanWrite)");
        sb.AppendLine("            {");
        GeneratePatchablePropertyCode(sb, prop);
        sb.AppendLine("            }");
        sb.AppendLine();
    }

    private static void GeneratePatchablePropertyCode(StringBuilder sb, PropertyModel prop)
    {
        // All properties are Patchable<T> - check HasValue
        var innerType = prop.PatchableInnerType ?? "object";
        sb.AppendLine($"                var existing{prop.Name}Value = prop{prop.Name}.GetValue(existing);");
        sb.AppendLine($"                context.Old{prop.Name} = ({innerType})existing{prop.Name}Value;");
        sb.AppendLine($"                if (patch.{prop.Name}.HasValue)");
        sb.AppendLine("                {");
        sb.AppendLine($"                    var patchValue = patch.{prop.Name}.Value;");
        sb.AppendLine($"                    if (!Equals(existing{prop.Name}Value, patchValue))");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        context.New{prop.Name} = patchValue;");
        sb.AppendLine($"                        context.{prop.Name}Changed = true;");
        sb.AppendLine($"                        prop{prop.Name}.SetValue(updated, patchValue);");
        sb.AppendLine("                    }");
        sb.AppendLine("                    else");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        context.New{prop.Name} = ({innerType})existing{prop.Name}Value;");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("                else");
        sb.AppendLine("                {");
        sb.AppendLine($"                    context.New{prop.Name} = ({innerType})existing{prop.Name}Value;");
        sb.AppendLine("                }");
    }
}